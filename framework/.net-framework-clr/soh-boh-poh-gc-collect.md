# SOH, LOH, POH, GC Collect

## First of all

대형 개체 힙 살펴보기

기존의 CLR의 Garbege Collection은 인스턴스를 소형과 대형 두가지 나누어요.

저는 이러한 인스턴스를 나누는 기준이 무엇인지, 어떻게 수집하는지, 그리고 각각의 인스턴스가 성능에는 어떤 영향을 미치는지에 대해 설명해보려고 해요.

## Large of heap

Microsoft .NET Framework 에서는 85,000바이트 이상의 개체가 대형 개체로 간주됩니다. 이는 성능 조정의 결과로 결정된 수치입니다. 수신된 개체 할당 요청이 크기 임계값에 도달하면 해당 개체는 대형 개체 힙에 할당됩니다. 이것이 정확히 의미하는 바는 무엇일까요? 이해를 돕기 위해 .NET 가비지 수집기의 기본적인 내용을 잠시 설명하겠습니다.

잘 알려진 사실이지만 .NET 가비지 수집기는 세대 기반의 수집기입니다. 가비지 수집기에는 0세대, 1세대, 2세대가 있습니다. 이렇게 개체를 세대별로 두는 것은 잘 조정된 응용 프로그램에서 대부분의 개체가 0세대에 소멸되도록 하기 위해서입니다. 예를 들어 서버 응용 프로그램에서 각 요청과 관련한 할당은 요청이 끝난 후에 소멸됩니다. 전송 중인 할당 요청은 1세대가 되어 소멸됩니다. 기본적으로 1세대는 생성된지 얼마 되지 않은 개체 영역과 오래된 개체 영역 간의 버퍼 역할을 합니다.

세대 관점에서 보면 대형 개체는 2세대 수집이 발생하는 경우에만 수집되므로 2세대에 속합니다. 특정 세대가 수집되면 그 이전 세대도 모두 수집됩니다. 예를 들어 1세대 가비지 수집이 발생하면 1세대와 0세대가 모두 수집되고 2세대 가비지 수집이 발생하면 전체 힙이 수집됩니다. 따라서 2세대 가비지 수집을 전체 가비지 수집이라고도 합니다. 이 칼럼에서는 전체 가비지 수집 대신 2세대 가비지 수집이라는 용어를 사용하겠지만 이 둘은 같은 의미입니다.

세대는 가비지 수집 힙을 논리적인 관점에서 표현한 것입니다. 실제로 개체는 관리되는 힙 세그먼트에 위치합니다. 관리되는 힙 세그먼트는 가비지 수집기가 관리 코드 대신 VirtualAlloc을 통해 OS에서 예약하는 메모리 청크입니다. CLR이 로드되면 두 개의 초기 힙 세그먼트가 할당됩니다\(소형 개체와 대형 개체에 하나씩\). 여기서는 이러한 힙 세그먼트를 각각 SOH\(소형 개체 힙\)과 LOH\(대형 개체 힙\)이라고 하겠습니다.

  


## Assign

할당 요청은 이러한 관리되는 힙 세그먼트 중 하나에 관리되는 개체를 넣는 방식으로 처리됩니다. 개체가 85,000바이트보다 작으면 SOH 세그먼트에 넣고 그렇지 않으면 LOH에 넣습니다. 할당되는 개체의 수가 늘어나면 세그먼트는 더 작은 청크로 커밋됩니다.

SOH의 경우 가비지 수집에서 제외된 개체는 다음 세대로 승격됩니다. 즉, 0세대 수집에서 제외된 개체는 1세대 개체로 간주되는 식입니다. 가장 오래된 세대에서 제외된 개체는 그대로 가장 오래된 세대로 간주됩니다. 즉, 2세대에서 제외된 개체는 2세대 개체가 되고 LOH에서 제외된 개체는 LOH 개체\(2세대와 함께 수집됨\)가 됩니다. 사용자 코드에서는 0세대\(소형 개체\)나 LOH\(대형 개체\)만 할당할 수 있습니다. 가비지 수집기만 1세대\(0세대에서 제외된 개체를 승격\)와 2세대\(1, 2세대에서 제외된 개체를 승격\)에 개체를 "할당"할 수 있습니다.

  
가비지 수집이 트리거되면 가비지 수집기는 살아 있는 개체를 모두 추적하여 압축합니다. 그러나 LOH의 경우 압축하는 데 리소스가 많이 소모되기 때문에 CLR 팀에서는 소멸된 개체 중에서 나중에 대형 개체 할당 요청을 처리하는 데 재사용 가능한 개체를 사용 가능 목록으로 만들어 LOH를 정리하는 방법을 선택했습니다. 즉, 인접한 소멸된 개체들이 하나의 사용 가능한 개체가 됩니다.

지금은 LOH를 압축하지 않지만 나중에는 압축할 수도 있다는 점을 유의해야 합니다. 따라서 대형 개체를 할당할 때 개체가 이동되지 않도록 하려면 개체를 고정해야 합니다.  
이 칼럼의 그림은 설명을 위한 그림일 뿐입니다. 힙이 어떻게 움직이는지 보여 주기 위해 소수의 개체만 사용했습니다. 실제로는 개체 수가 훨씬 많습니다.  
그림 1은 첫 번째 0세대 GC가 발생하여 Obj1과 Obj3이 소멸된 후 1세대를 형성하고, 첫 번째 1세대 GC가 발생하여 Obj2와 Obj5가 소멸된 후 2세대를 형성하는 시나리오를 보여 줍니다.



## Reference.

{% embed url="http://www.simpleisbest.net/post/2011/04/11/Large-Object-Heap-Intro.aspx" %}



